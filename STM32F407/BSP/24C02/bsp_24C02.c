/***********************************************************************************************************************************
 **【淘宝链接】  魔女开发板    https://demoboard.taobao.com
 ***********************************************************************************************************************************
 **【文件名称】  bsp_AT24C02.c
 **【文件功能】
 **
 **【适用平台】  STM32F407 + 标准库v1.8 + keil5
 **
 **【更新记录】  2020-03-05  创建
 **              2021-05-03  完善文件格式、注释格式
 **
************************************************************************************************************************************/
#include "bsp_24C02.h"



// 声明全局变量,方便记录数据
xAT24C02_TypeDef  xAT24C02;



// 粗略延时：ms
static void delay_ms(uint32_t ms)                     // 定义一个ms延时函数，减少移植时对外部文件依赖; 本函数仅作粗略延时使用，而并非精准延时;
{
    ms = ms * 42001;                                  // 注意：此参考值运行条件：打勾 Options/ c++ / One ELF Section per Function
    for (uint32_t i = 0; i < ms; i++);                // 注意系统时钟下，大约多少个空循环耗时1ms
}



/*********************************************************************************************************
 * 函  数：AT24C02_ReadBytes
 * 功  能：读取指定数量的数据
 * 参  数：uint16_t    _uDataAddr    数据地址
 *         uint8_t    *_puDataBuf    存放数据的缓存地址
 *         uint16_t    _uNum         要读取的字节数
 * 返回值：0-失败，1-成功
********************************************************************************************************/
uint8_t AT24C02_ReadBytes(uint8_t _uDataAddr, uint8_t *_puDataBuf, uint16_t _uNum)
{
    if (xAT24C02.initOK == 0)                                                   // 检查设备的初始化是否正常。此值在AT24C02_Init()中被赋值
        return 0;                                                               // 返回：0-异常
    return I2CSoft_ReadBytes(AT24C02_DEV_ADDR, _uDataAddr, _puDataBuf, _uNum);  // 直接调用I2CSoft_ReadBytes()，返回：0-失败，1-成功
}



/*********************************************************************************************************
 * 函  数：AT24C02_WriteBytes
 * 功  能：写入指定数量的数据
 * 参  数：uint16_t    _uDataAddr    数据地址
 *         uint8_t    *_puDataBuf    存放数据的缓存地址
 *         uint16_t    _uNum         要写入的字节数
 * 返回值：0-失败，1-成功
 * 备  注：多字节读取时，不能直接调用I2CSoft_WriteBytes(), 因为24C02的写操作要分页;
 *         和连续读操作不同，24C02的写操作，每次写指令，只能在同一个页内进行;
 *         当发送第1个字节、遇页首地址，都需要发送开始信号、写指令、数据地址;
 *         24C02每页是8字节，04或以上每页是16字节;
********************************************************************************************************/
uint8_t AT24C02_WriteBytes(uint8_t _uDataAddr, uint8_t *_puDataBuf, uint16_t _uNum)
{
    uint16_t  errTimes;
    uint16_t addr = _uDataAddr;

    if (xAT24C02.initOK == 0)                                   // 检查设备的初始化是否正常。此值在AT24C02_Init()中被赋值
        return 0;                                               // 返回：0-异常

    for (uint16_t i = 0; i < _uNum; i++)
    {
        if ((i == 0) || (addr & (AT24C02_PAGE_SIZE - 1)) == 0)  // 当发送第1个字节、页首地址时，都需要重新发送开始信号、数据地址
        {
            I2CSoft_Stop();                                     // 停止信号

            for (errTimes = 0; errTimes < 1000; errTimes++)     // 通过检查器件应答的方式，判断内部写操作是否完成, 一般小于 10ms,    CLK频率为200KHz时，查询次数为30次左右
            {
                I2CSoft_Start();                                // 开始信号

                I2CSoft_SendByte(AT24C02_DEV_ADDR | 0);         // 发送从机地址+写控制，注意：这里是写控制 （0-写、1-读)
                if (I2CSoft_WaitAck() == 0)                     // 等待ACK。注意：每发送一个字节，都要确认从机应答
                    break;                                      // 从机无应答, 跳到失败处理(产生停止信号、返回0)
            }
            if (errTimes >= 999)
                goto write_ACK_Fail;                            // 从机无应答, 跳到失败处理(产生停止信号、返回0)

            I2CSoft_SendByte((uint8_t)addr);                    // 发送数据地址。注意：24C02只有256字节，只需发送1个数据地址值，如果24C04或以上就要发送两个数据地址值
            if (I2CSoft_WaitAck())                              // 等待ACK。注意：每发送一个字节，都要确认从机应答
                goto write_ACK_Fail;                            // 从机无应答, 跳到失败处理(产生停止信号、返回0)
        }

        I2CSoft_SendByte(_puDataBuf[i]);                        // 发送数据
        if (I2CSoft_WaitAck())                                  // 等待ACK。注意：每发送一个字节，都要确认从机应答
            goto write_ACK_Fail;                                // 从机无应答, 跳到失败处理(产生停止信号、返回0)

        addr++;                                                 // 地址递增
    }

    I2CSoft_Stop();                                             // 写入操作完成，向总线发送停止信号
    return 1;

write_ACK_Fail:                                                 // 失败处理
    I2CSoft_Stop();                                             // 发送停止信号
    return 0;                                                   // 返回 0
}



/*********************************************************************************************************
 * 函  数：AT24C02_Init
 * 功  能：初始化模拟I2C的总线引脚、信号，并测试
 * 参  数：
 * 返回值：0-异常，1-正常
********************************************************************************************************/
uint8_t AT24C02_Init(void)
{
    xAT24C02.initOK = 0;                             // 赋值，0-异常，1-正常

    I2CSoft_Init();                                  // 1-初始化I2C总线引脚

    if (I2CSoft_CheckDevice(AT24C02_DEV_ADDR))       // 2-测试芯片是否有回应，以检查线路是否连接正常; 0-检测到设备回应，1-未检测到设备回应
    {
        I2CSoft_Stop();                              // 没有回答，向总线发送停止信号
        printf("24C02 尝试连接...        失败，没有检测到回应信号\r\n");
        return 0;
    }
    
    xAT24C02.initOK = 1;                             // 赋值，0-异常，1-正常

#if 1
    printf("24C02 读写检查...        ");             // 3-进行整片读写测试：先保存旧数据，整芯片写入0xFF，读对比，最后写回原来旧数据
    uint8_t oldData[AT24C02_SIZE];                   // 临时缓存，存放芯片旧数据
    uint8_t testData[AT24C02_SIZE];                  // 临时缓存，存放测试数据
    memset(oldData, 0X00, AT24C02_SIZE);             // 旧数据缓存，清0
    AT24C02_ReadBytes(0, oldData, AT24C02_SIZE);     // 先把旧数据，全部读出来, 测试后再写回去，使测试不破坏旧数据
    memset(testData, 0xFF, AT24C02_SIZE);            // 把测试数据全部置0xFF
    AT24C02_WriteBytes(0, testData, AT24C02_SIZE);   // 写入测试数据，如果写入成功，芯片内部数据应该全部是0xFF
    memset(testData, 0x00, AT24C02_SIZE);            // 把测试缓存中的数据全部置0x0
    delay_ms(10);                                    // 写入后，不能立即再读写，需要稍作延时，不然会出错
    AT24C02_ReadBytes(0, testData, AT24C02_SIZE);    // 把芯片内的数据，全部读出来
    for (uint16_t i = 0; i < AT24C02_SIZE; i++)      // 把写入后读出来的数据，逐个对比
    {
        if (testData[i] != 0xFF)                     // 读写不一致
        {
            printf("错误: 读写数据不一致\r\n");      // 提示原因
            return 0;                                // 失败，返回 0
        }
    }
    printf("正常\r\n");
    AT24C02_WriteBytes(0, oldData, AT24C02_SIZE);    // 写回旧数据
    delay_ms(10);                                    // 写入后，不能立即再读写，需要稍作延时，不然会出错
#endif
    
    return 1;                                        // 返回，0-异常，1-正常
}


